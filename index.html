<script type="module">
import {
  FilesetResolver,
  HandLandmarker,
  FaceLandmarker,
  DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

/* URLs oficiales de modelos (Google Storage) */
const HAND_MODEL_URL = "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task";
const FACE_MODEL_URL = "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task";

/* ========= Entorno seguro ========= */
const envHint = document.getElementById('envHint');
if (!location.protocol.startsWith('https') && location.hostname !== 'localhost') {
  envHint && (envHint.textContent = "Abre en HTTPS o localhost para usar la cámara.");
}

/* ============== UI ============== */
const controlsGrid = document.querySelector('.controls');
const startBtn = document.getElementById('startBtn');
const stopBtn  = document.getElementById('stopBtn');
const muteBtn  = document.getElementById('muteBtn');
const camStatus= document.getElementById('camStatus');
const webcamEl = document.getElementById('webcam');
const canvas   = document.getElementById('overlay');
const ctx      = canvas.getContext('2d');
const hud      = document.getElementById('hud');

const leftInstrument  = document.getElementById('leftInstrument');
const rightInstrument = document.getElementById('rightInstrument');
const scaleRoot = document.getElementById('scaleRoot');
const scaleType = document.getElementById('scaleType');
const volume = document.getElementById('volume');
const perfMode = document.getElementById('perfMode');
const mirrorSel = document.getElementById('mirror');
const drawSel   = document.getElementById('draw');

/* ====== Banco de sonidos (inyectado por JS) ====== */
const SOUND_SETS = {
  electronico: ["Sintetizador","Piano","Guitarra","Violín","Brass","Órgano"],
  regional:    ["Acordeón","Tuba","Trompeta","Vihuela","Bajo sexto"]
};
let soundSet = localStorage.getItem('soundSet') || 'electronico';

// crear selector en la barra sin tocar el HTML
const soundRow = document.createElement('div');
soundRow.className = 'row';
soundRow.style.gridColumn = 'span 3';
soundRow.innerHTML = `
  <label class="tag">Banco de sonidos</label>
  <select id="soundSetSel" class="select">
    <option value="electronico">Electrónico (Fifí)</option>
    <option value="regional">Regional (Pueblo)</option>
  </select>
`;
controlsGrid.appendChild(soundRow);
const soundSetSel = soundRow.querySelector('#soundSetSel');
soundSetSel.value = soundSet;

/* ============ Estado global ============ */
let vision, handLandmarker, faceLandmarker;
let running = false;
let maxHands = 2;
let mirror = true;
let drawLandmarks = true;
let stream = null;

/* ============== Audio ============== */
const AudioEngine = (() => {
  const AC = window.AudioContext || window.webkitAudioContext;
  const ctx = new AC({ latencyHint: 'interactive' });
  const master = ctx.createGain(); master.gain.value = 0.85;
  const limiter = ctx.createDynamicsCompressor();
  limiter.threshold.value = -8; limiter.knee.value = 14; limiter.ratio.value = 12;
  limiter.attack.value = 0.002; limiter.release.value = 0.09;
  limiter.connect(master); master.connect(ctx.destination);

  // Utilidades musicales
  const noteFreq = (note) => {
    const A4 = 440;
    const map = {C:0, 'C#':1, Db:1, D:2, 'D#':3, Eb:3, E:4, F:5, 'F#':6, Gb:6, G:7, 'G#':8, Ab:8, A:9, 'A#':10, Bb:10, B:11};
    const m = note.match(/^([A-G]#?|Bb|Db|Gb)(\d)$/);
    const n = map[m[1]]; const o = parseInt(m[2],10);
    return A4 * Math.pow(2, (n - 9 + (o - 4)*12)/12);
  };
  const buildScale = (root="C4", type="major") => {
    const intervals = {
      major:[0,2,4,5,7,9,11,12],
      minor:[0,2,3,5,7,8,10,12],
      pentatonic:[0,2,4,7,9,12],
      blues:[0,3,5,6,7,10,12]
    }[type] || [0,2,4,5,7,9,11,12];
    const baseTable = {'C':0,'C#':1,'D':2,'D#':3,'E':4,'F':5,'F#':6,'G':7,'G#':8,'A':9,'A#':10,'B':11,'Bb':10,'Db':1,'Gb':6,'Ab':8,'Eb':3};
    const mm = root.match(/^([A-G]#?|Bb|Db|Gb)(\d)$/);
    const base = baseTable[mm[1]]; const octave = parseInt(mm[2],10);
    const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    return intervals.map(semi=>{
      const total = base + semi + octave*12;
      return `${names[(total%12+12)%12]}${Math.floor(total/12)}`;
    });
  };

  // Pequeño helper para LFO
  const makeLFO = (freq=5, destParam, depth=10, type='sine')=>{
    const lfo = ctx.createOscillator(); lfo.type = type; lfo.frequency.value = freq;
    const g = ctx.createGain(); g.gain.value = depth;
    lfo.connect(g); g.connect(destParam);
    lfo.start();
    return { lfo, g };
  };

  // Presets por instrumento (ambos bancos)
  function applyPreset(name, o){
    // Electrónico
    if (name==="Sintetizador"){ o.osc.type='sawtooth'; o.osc2.type='square'; o.filter.frequency.value=12000; }
    else if (name==="Piano"){ o.osc.type='triangle'; o.osc2.type='square'; o.filter.frequency.value=6000; }
    else if (name==="Guitarra"){ o.osc.type='sawtooth'; o.osc2.type='sawtooth'; o.filter.frequency.value=4200; }
    else if (name==="Violín"){ o.osc.type='sawtooth'; o.osc2.type='sawtooth'; o.filter.frequency.value=8000; }
    else if (name==="Brass"){ o.osc.type='square'; o.osc2.type='square'; o.filter.frequency.value=5000; }
    else if (name==="Órgano"){ o.osc.type='square'; o.osc2.type='triangle'; o.filter.frequency.value=10000; }

    // Regional (emulaciones rápidas WebAudio)
    else if (name==="Acordeón"){
      o.osc.type='sawtooth'; o.osc2.type='sawtooth';
      o.detune = 8; // leve desafinación
      o.osc.detune.value = -o.detune; o.osc2.detune.value = +o.detune;
      o.filter.frequency.value = 3500; o.filter.Q.value=0.8;
      // LFO leve de volumen (~vibrato/tremolo)
      const trem = makeLFO(5, o.gain.gain, 0.05, 'sine'); o.lfo = trem;
    }
    else if (name==="Tuba"){
      o.osc.type='sine'; o.osc2.type='square';
      o.filter.frequency.value = 2200; o.filter.Q.value=0.7;
      o.envShape = {a:0.012, d:0.12, s:0.75};
    }
    else if (name==="Trompeta"){
      o.osc.type='square'; o.osc2.type='sawtooth';
      o.filter.frequency.value = 7500; o.filter.Q.value=0.9;
      o.pitchEnv = true; // pequeño “ataque” de tono
    }
    else if (name==="Vihuela" || name==="Bajo sexto"){
      o.osc.type='triangle'; o.osc2.type='triangle';
      o.filter.frequency.value = 3800; o.filter.Q.value=0.9;
      o.pluck = true; // ataque más percutivo
    }
  }

  const createVoice = (instrument="Sintetizador", dest=limiter) => {
    const o = {};
    o.gain = ctx.createGain(); o.gain.gain.value = 0; o.gain.connect(dest);
    o.filter = ctx.createBiquadFilter(); o.filter.type='lowpass'; o.filter.frequency.value = 12000; o.filter.Q.value=0.7; o.filter.connect(o.gain);
    o.osc = ctx.createOscillator(); o.osc2 = ctx.createOscillator(); o.osc.frequency.value = 220; o.osc2.frequency.value = 220; o.osc.start(); o.osc2.start();
    o.mix = ctx.createGain(); o.mix.gain.value = .72; o.osc.connect(o.mix); o.osc2.connect(o.mix); o.mix.connect(o.filter);

    // Ruido para ataque “cuerdas”
    const buf = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
    const data = buf.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
    const noise = ctx.createBufferSource(); noise.buffer=buf; noise.loop=true; noise.start();
    o.noiseGain = ctx.createGain(); o.noiseGain.gain.value=0; noise.connect(o.noiseGain); o.noiseGain.connect(o.filter);

    applyPreset(instrument, o);

    o.setFreq = (f)=>{
      const now = ctx.currentTime;
      // pitch “env” para trompeta
      if (o.pitchEnv){
        o.osc.frequency.cancelScheduledValues(now);
        o.osc2.frequency.cancelScheduledValues(now);
        o.osc.frequency.setValueAtTime(f*1.03, now);
        o.osc2.frequency.setValueAtTime(f*1.03, now);
        o.osc.frequency.exponentialRampToValueAtTime(Math.max(20,f), now+0.05);
        o.osc2.frequency.exponentialRampToValueAtTime(Math.max(20,f), now+0.05);
      }else{
        o.osc.frequency.exponentialRampToValueAtTime(Math.max(20,f), now+0.01);
        o.osc2.frequency.exponentialRampToValueAtTime(Math.max(20,f*0.999), now+0.01);
      }
    };
    o.env = (target=0.65, a=0.008, d=0.06, s=0.55)=>{
      if (o.envShape){ a=o.envShape.a; d=o.envShape.d; s=o.envShape.s; }
      const now = ctx.currentTime;
      o.gain.gain.cancelScheduledValues(now);
      o.gain.gain.linearRampToValueAtTime(target, now+a);
      o.gain.gain.linearRampToValueAtTime(target*s, now+a+d);
    };
    o.release = (r=0.12)=>{
      const now=ctx.currentTime;
      o.gain.gain.cancelScheduledValues(now);
      o.gain.gain.setTargetAtTime(0, now, r);
    };
    o.strike = (tone=440, velo=1)=>{
      o.setFreq(tone);
      // “Pluck” para cuerdas tipo vihuela/bajo
      if (o.pluck){
        o.noiseGain.gain.cancelScheduledValues(ctx.currentTime);
        o.noiseGain.gain.setValueAtTime(0.11*velo, ctx.currentTime);
        o.noiseGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.04);
        o.env(Math.min(0.8,0.5+0.4*velo), 0.003, 0.05, 0.45);
      } else {
        o.noiseGain.gain.cancelScheduledValues(ctx.currentTime);
        o.noiseGain.gain.setValueAtTime(0.06*velo, ctx.currentTime);
        o.noiseGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime+0.06);
        o.env(Math.min(0.8,0.35+0.5*velo), 0.004, 0.05, 0.6);
      }
    };
    return o;
  };

  // Percusión -> dos “sabores” según banco
  const Drums = (()=> {
    const kick = (vel=1)=>{
      const osc = ctx.createOscillator(); osc.type='sine';
      const g = ctx.createGain(); g.gain.value=0.0001;
      // bombo más profundo si regional
      const f0 = (soundSet==='regional') ? 90 : 120;
      const f1 = (soundSet==='regional') ? 38 : 45;
      osc.frequency.setValueAtTime(f0, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(f1, ctx.currentTime+0.18);
      g.gain.setValueAtTime(0.95*vel, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.22);
      osc.connect(g); g.connect(limiter); osc.start(); osc.stop(ctx.currentTime+0.25);
    };
    const snare = (vel=1)=>{
      const noiseBuf = ctx.createBuffer(1, ctx.sampleRate*0.6, ctx.sampleRate);
      const data = noiseBuf.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
      const noise = ctx.createBufferSource(); noise.buffer=noiseBuf;
      const bp = ctx.createBiquadFilter(); bp.type='bandpass';
      bp.frequency.value = (soundSet==='regional') ? 1800 : 2500;
      bp.Q.value = (soundSet==='regional') ? 0.7 : 0.5;
      const g = ctx.createGain(); g.gain.value=(soundSet==='regional')? 1.0*vel : 0.9*vel;
      noise.connect(bp); bp.connect(g); g.connect(limiter);
      noise.start();
      const dur = (soundSet==='regional') ? 0.22 : 0.18;
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dur);
      noise.stop(ctx.currentTime+dur+0.02);
    };
    const hihat = (open=false, vel=1)=>{
      const noiseBuf = ctx.createBuffer(1, ctx.sampleRate*0.5, ctx.sampleRate);
      const data = noiseBuf.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
      const noise = ctx.createBufferSource(); noise.buffer=noiseBuf;
      const hp = ctx.createBiquadFilter(); hp.type='highpass';
      hp.frequency.value = (soundSet==='regional') ? 8000 : 7000;
      hp.Q.value = 0.8;
      const g = ctx.createGain(); g.gain.value=(soundSet==='regional')? 0.7*vel : 0.6*vel;
      noise.connect(hp); hp.connect(g); g.connect(limiter);
      noise.start();
      const dur = open ? ((soundSet==='regional')? 0.42 : 0.35) : 0.08;
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dur);
      noise.stop(ctx.currentTime+dur+0.02);
    };
    const crash = (vel=1)=>{
      const noiseBuf = ctx.createBuffer(1, ctx.sampleRate*1.5, ctx.sampleRate);
      const data = noiseBuf.getChannelData(0); for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1;
      const noise = ctx.createBufferSource(); noise.buffer=noiseBuf;
      const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=5200; bp.Q.value=0.35;
      const g = ctx.createGain(); g.gain.value=0.55*vel;
      noise.connect(bp); bp.connect(g); g.connect(limiter);
      noise.start();
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.9);
      noise.stop(ctx.currentTime+0.95);
    };
    return { kick, snare, hihat, crash };
  })();

  return {
    ctx, master,
    setVolume(v){ master.gain.value = v; },
    buildScale, noteFreq, createVoice,
    drums: Drums
  };
})();

/* ======== Escalas / asignaciones ======== */
let scale = AudioEngine.buildScale("C4","major");
const fingerToDegree = { thumb:0, index:1, middle:2, ring:3, pinky:4 };
const fingerMap = ["thumb","index","middle","ring","pinky"];

function degreeToFreq(deg, bias=0){
  const idx = Math.min(scale.length-1, Math.max(0, deg));
  const note = scale[idx];
  const base = AudioEngine.noteFreq(note);
  return base * Math.pow(2, bias/12);
}
function updateScale(){
  scale = AudioEngine.buildScale(scaleRoot.value, scaleType.value);
}
scaleRoot.addEventListener('change', updateScale);
scaleType.addEventListener('change', updateScale);
volume.addEventListener('input', e=> AudioEngine.setVolume(parseFloat(e.target.value)));

/* ======= Landmarks dibujo ======= */
const drawUtils = new DrawingUtils(ctx);
function drawHands(res){
  if(!drawLandmarks) return;
  ctx.save();
  res?.landmarks?.forEach((lm)=>{
    drawUtils.drawConnectors(lm, HandLandmarker.HAND_CONNECTIONS,{color:"#5dd6ff"});
    drawUtils.drawLandmarks(lm, {color:"#44d19f", radius:2.2});
  });
  ctx.restore();
}
function drawFace(res){
  if(!drawLandmarks) return;
  ctx.save();
  res?.faceLandmarks?.forEach(lm=>{
    drawUtils.drawLandmarks(lm, {color:"#ffc857", radius:1.8});
  });
  ctx.restore();
}

/* ============= Utilidades ============= */
const handedKey = (handedness)=> handedness.toLowerCase().startsWith("left") ? "L":"R";
function isFingerExtended(landmarks, finger, HK){
  const idx = { thumb:[1,2,3,4], index:[5,6,7,8], middle:[9,10,11,12], ring:[13,14,15,16], pinky:[17,18,19,20] }[finger];
  const [mcp, pip, , tip] = idx.map(i=> landmarks[i]);
  if(finger === "thumb"){
    if(HK==="R"){ return tip.x > mcp.x + 0.06; } else { return tip.x < mcp.x - 0.06; }
  }else{
    return (pip.y - tip.y) > 0.035;
  }
}
function wristGain(landmarks){
  const w = landmarks[0];
  return Math.min(1, Math.max(0, 1 - w.y));
}
function lerp(a,b,t){ return a + (b-a)*t; }

/* ======= Voces por dedo/mano ======= */
const activeVoices = {}; // key "L_index" -> voice
function ensureVoice(key, instrument){
  if(!activeVoices[key]){
    activeVoices[key] = AudioEngine.createVoice(instrument);
  }
  return activeVoices[key];
}
function stopVoice(key){
  if(activeVoices[key]) activeVoices[key].release();
}

/* =========== Cara → Percusión =========== */
const faceState = { blinkL:false, blinkR:false, mouth:false, tongue:false };
function getBlendmap(blendshapes){
  const map = {};
  blendshapes?.categories?.forEach(c => map[c.categoryName] = c.score);
  return map;
}
function edge(prev, now, th=0.55){ return (!prev && now>th); }

function processFace(result){
  if(!result) return;
  const bm = getBlendmap(result.faceBlendshapes?.[0] || {});
  const blinkL  = bm["eyeBlinkLeft"]  ?? 0;
  const blinkR  = bm["eyeBlinkRight"] ?? 0;
  const mouthOpen = (bm["mouthOpen"] ?? 0) + (bm["jawOpen"] ?? 0)*0.5;
  const tongue   = bm["tongueOut"] ?? 0;

  // mapeo “tambora” si regional, si no percusión general
  if(edge(faceState.blinkL, blinkL)) AudioEngine.drums.hihat(false, 0.9);  // hi-hat cerrado / golpe de aro
  if(edge(faceState.blinkR, blinkR)) AudioEngine.drums.hihat(true, 0.9);   // hi-hat abierto / platillo
  if(edge(faceState.mouth, mouthOpen, 0.6)) AudioEngine.drums.snare(1.0);  // caja / redoble corto
  if(edge(faceState.tongue, tongue, 0.55)) AudioEngine.drums.crash(1.0);   // crash

  // Bombo si parpadean ambos
  if( (blinkL>0.6 && blinkR>0.6) && !(faceState.blinkL && faceState.blinkR) ){
    AudioEngine.drums.kick(1.0);
  }

  faceState.blinkL = blinkL>0.55;
  faceState.blinkR = blinkR>0.55;
  faceState.mouth  = mouthOpen>0.6;
  faceState.tongue = tongue>0.55;

  hud.innerHTML = `
    <span class="pill">${(blinkL>0.55?'👁️‍🗨️':'👁️')} L</span>
    <span class="pill">${(blinkR>0.55?'👁️‍🗨️':'👁️')} R</span>
    <span class="pill">${(mouthOpen>0.6?'🗣️ BOCA':'🙂')}</span>
    <span class="pill">${(tongue>0.55?'👅 LENGUA':'👄')}</span>
  `;
}

/* ========== Bucle de inferencia ========== */
let lastInfer = 0;
const SPEEDS = { speed:1/45, balanced:1/30, quality:1/20 };

async function loop(){
  if(!running) return;
  const now = performance.now()/1000;
  const minDelta = SPEEDS[perfMode.value] || SPEEDS.balanced;
  if(now - lastInfer >= minDelta){
    lastInfer = now;
    const ts = performance.now();
    const hands = await handLandmarker.detectForVideo(webcamEl, ts);
    const face  = await faceLandmarker.detectForVideo(webcamEl, ts);

    ctx.clearRect(0,0,canvas.width, canvas.height);
    if(drawLandmarks){ drawHands(hands); drawFace(face); }

    processHands(hands);
    processFace(face);
  }
  requestAnimationFrame(loop);
}

/* ====== Motor musical de manos ====== */
const smoothY = {};
function processHands(result){
  if(!result) return;
  for(let i=0;i<result.handedness.length;i++){
    const handed = result.handedness[i][0].categoryName; // "Right"/"Left"
    const HK = handedKey(handed); // "L" | "R"
    const instrument = HK==="L" ? leftInstrument.value : rightInstrument.value;
    const lm = result.landmarks[i];

    const g = wristGain(lm);
    for(const finger of fingerMap){
      const key = `${HK}_${finger}`;
      const deg = fingerToDegree[finger];
      const tipIndex = {thumb:4,index:8,middle:12,ring:16,pinky:20}[finger];
      const tip = lm[tipIndex];
      const idKey = `${key}_tip`;
      const sy = smoothY[idKey] = lerp(smoothY[idKey] ?? tip.y, tip.y, 0.35);

      const pitchBias = Math.round((0.5 - sy) * 24); // ±12
      const freq = degreeToFreq(deg, pitchBias);

      const extended = isFingerExtended(lm, finger, HK);
      if(extended){
        const v = ensureVoice(key, instrument);
        v.strike(freq, Math.max(0.2, g));
        v.gain.gain.value = Math.min(0.9, (0.25 + 0.7*g));
      }else{
        stopVoice(key);
      }
    }
  }
}

/* =========== Cámara / Modelos =========== */
async function setupCamera(){
  stream = await navigator.mediaDevices.getUserMedia({
    video: { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:60, max:60} },
    audio: false
  });
  webcamEl.srcObject = stream;
  await webcamEl.play();

  const vw = webcamEl.videoWidth, vh = webcamEl.videoHeight;
  canvas.width = vw; canvas.height = vh;
  ctx.setTransform(1,0,0,1,0,0);
  if(mirrorSel.value==="1"){ ctx.translate(canvas.width,0); ctx.scale(-1,1); }
}
async function loadModels(){
  const wasmBase = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm";
  vision = await FilesetResolver.forVisionTasks(wasmBase);
  handLandmarker = await HandLandmarker.createFromOptions(vision, {
    baseOptions: { modelAssetPath: HAND_MODEL_URL },
    numHands: maxHands,
    runningMode: "VIDEO"
  });
  faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
    baseOptions: { modelAssetPath: FACE_MODEL_URL },
    runningMode: "VIDEO",
    numFaces: 1,
    outputFaceBlendshapes: true,
    outputFacialTransformationMatrixes: false
  });
}

/* =========== Helpers de UI =========== */
function setInstrumentOptions(forSet){
  const arr = SOUND_SETS[forSet];
  const rebuild = (sel) => {
    const prev = sel.value;
    sel.innerHTML = arr.map(x=>`<option>${x}</option>`).join('');
    // intenta conservar si coincide por nombre
    if (arr.includes(prev)) sel.value = prev;
  };
  rebuild(leftInstrument);
  rebuild(rightInstrument);
}
setInstrumentOptions(soundSet);

soundSetSel.addEventListener('change', ()=>{
  soundSet = soundSetSel.value;
  localStorage.setItem('soundSet', soundSet);
  setInstrumentOptions(soundSet);
});

mirrorSel.addEventListener('change', e=> mirror = e.target.value==="1");
drawSel.addEventListener('change', e=> drawLandmarks = e.target.value==="1");

/* =========== Controles =========== */
startBtn.addEventListener('click', async ()=>{
  startBtn.disabled = true;
  try{
    await AudioEngine.ctx.resume();
    AudioEngine.setVolume(parseFloat(volume.value));
    await setupCamera();
    await loadModels();
    camStatus.className = "status-dot ok";
    running = true;
    stopBtn.disabled = false;
    loop();
  }catch(err){
    console.error(err);
    camStatus.className = "status-dot err";
    alert("No se pudo iniciar cámara/modelos: " + (err?.message || err));
    startBtn.disabled = false;
  }
});

stopBtn.addEventListener('click', ()=>{
  running = false;
  stopBtn.disabled = true;
  startBtn.disabled = false;
  camStatus.className = "status-dot warn";
  Object.keys(activeVoices).forEach(k=> stopVoice(k));
  if(stream){ stream.getTracks().forEach(t => t.stop()); stream = null; }
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
});

muteBtn.addEventListener('click', ()=>{
  AudioEngine.setVolume(0);
  volume.value = 0;
});
window.addEventListener('resize', ()=>{
  if(webcamEl.videoWidth){
    canvas.width = webcamEl.videoWidth; canvas.height = webcamEl.videoHeight;
    ctx.setTransform(1,0,0,1,0,0);
    if(mirrorSel.value==="1"){ ctx.translate(canvas.width,0); ctx.scale(-1,1); }
  }
});
</script>
